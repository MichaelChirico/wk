<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Understanding the wk C and C++ API • wk</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../../bootstrap-toc.css">
<script src="../../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><meta property="og:title" content="Understanding the wk C and C++ API">
<meta property="og:description" content="wk">
<meta name="robots" content="noindex">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../../index.html">wk</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">0.3.3.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/articles/philosophy.html">Understanding the wk C and C++ API</a>
    </li>
  </ul>
</li>
<li>
  <a href="../../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/paleolimbot/wk/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="philosophy_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Understanding the wk C and C++ API</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/paleolimbot/wk/blob/master/vignettes/articles/philosophy.Rmd"><code>vignettes/articles/philosophy.Rmd</code></a></small>
      <div class="hidden name"><code>philosophy.Rmd</code></div>

    </div>

    
    
<p>At the heart of the wk philosophy is the concept of a <strong>handler</strong>, whose job it is to respond to bits of geometric information as they are iterated over by the <strong>reader</strong>. These bits of information have a very specific structure and order such that the messages can be guaranteed to be backward-compatible for all time (for each version of the API). This means that the <strong>reader</strong> can focus on iterating over the data structure and <strong>handlers</strong> can focus on computing a value (usually) based on the geometries. The advantage of this system is that readers and handlers can be mixed and matched so that handlers can be used with many data structures! As an example, the wk package itself uses readers and handlers to power validation of and conversion between <code><a href="../../reference/wkt.html">wkt()</a></code>, <code><a href="../../reference/wkb.html">wkb()</a></code>, and <code><a href="../../reference/wksxp.html">wksxp()</a></code> classes.</p>
<p>The wk API works with a <strong>vector</strong> of <strong>features</strong>: readers iterate over such vectors and handlers compute a value based on some or all of the features in the vector. Each <strong>feature</strong> can be <code>NULL</code> or contain exactly one <strong>geometry</strong> (although this geometry can be a collection or multi-geometry which can contain a tree of other geometries). A good way to visualize the structure, order, and type of messages passed to a <strong>handler</strong> is to use the <code><a href="../../reference/wk_void_handler.html">wk_debug_handler()</a></code> on some well-known text (WKT):</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://paleolimbot.github.io/wk/">wk</a></span><span class="op">)</span>
<span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span>
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="st">"POINT (0 1)"</span>, <span class="st">"GEOMETRYCOLLECTION (POINT (2 3))"</span><span class="op">)</span>,
  <span class="fu"><a href="../../reference/wk_void_handler.html">wk_debug_handler</a></span><span class="op">(</span><span class="op">)</span>
<span class="op">)</span>
<span class="co">#&gt; vectorStart: &lt;Unknown type / 0&gt;[3] &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;   featureStart (1 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;     nullFeature (1 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;   featureEnd (1 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;   featureStart (2 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;     geometryStart: POINT &lt;0x7ffeea02db48&gt;</span>
<span class="co">#&gt;       coord (1 / 1) &lt;0x7ffeea02db48&gt; (0.000000 1.000000)</span>
<span class="co">#&gt;     geometryEnd &lt;0x7ffeea02db48&gt; </span>
<span class="co">#&gt;   featureEnd (2 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;   featureStart (3 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt;     geometryStart: GEOMETRYCOLLECTION &lt;0x7ffeea02db48&gt;</span>
<span class="co">#&gt;       geometryStart: POINT &lt;0x7ffeea02da48&gt;</span>
<span class="co">#&gt;         coord (1 / 1) &lt;0x7ffeea02da48&gt; (2.000000 3.000000)</span>
<span class="co">#&gt;       geometryEnd &lt;0x7ffeea02da48&gt; </span>
<span class="co">#&gt;     geometryEnd &lt;0x7ffeea02db48&gt; </span>
<span class="co">#&gt;   featureEnd (3 / 3) &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt; vectorEnd &lt;0x7ffeea02dcd8&gt;</span>
<span class="co">#&gt; vectorFinally()</span></code></pre></div>
<p>The concept of a <strong>vector</strong> was inspired by the <code><a href="https://r-spatial.github.io/sf/reference/sfc.html">sf::sfc()</a></code> data type and draws heavily from the <a href="https://vctrs.r-lib.org">vctrs</a> framework. The concept of a <strong>feature</strong> draws from the implementations of the simple features specification in most databases and the support in R for “missing” values, which are not quite the same as an EMPTY geometry (in the same way that <code>NaN</code> and <code>NA</code> can be distinguished in R). The concept of a <strong>geometry</strong> is very much tied to (and was inspired by) the definition of a geometry in the (E)WKB, (E)WKT, and TWKB format specifications such that most of the information provided by these formats is passed along to handlers if it is available.</p>
<div id="a-handler-in-c" class="section level2">
<h2 class="hasAnchor">
<a href="#a-handler-in-c" class="anchor"></a>A handler in C++</h2>
<p>As an example, I’ll write a handler that computes the 2D bounding box of its input (assuming Euclidean space). One way to go about this is to use the C++ extension of the C API. The approach is probably familiar: keep a running tally of the greatest and least values so far, updating every time information about a new coordinate is available.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11;</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">namespace</span> writable = cpp11::writable;</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#include </span><span class="im">"wk-v1.hpp"</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#include </span><span class="im">"wk-v1-impl.c"</span></span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">class</span> BBoxHandler: <span class="kw">public</span> WKVoidHandler {</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">public</span>:</span>
<span id="cb2-10"><a href="#cb2-10"></a>  BBoxHandler(): xmin(R_PosInf), ymin(R_PosInf), xmax(R_NegInf), ymax(R_NegInf) {}</span>
<span id="cb2-11"><a href="#cb2-11"></a>  </span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="dt">char</span> coord(<span class="at">const</span> <span class="dt">WKGeometryMeta_t</span>* meta, <span class="dt">WKCoord_t</span> coord, <span class="dt">uint32_t</span> nCoords, <span class="dt">uint32_t</span> coordId) {</span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="kw">this</span>-&gt;xmin = <span class="bu">std::</span>min(coord.v[<span class="dv">0</span>], <span class="kw">this</span>-&gt;xmin);</span>
<span id="cb2-14"><a href="#cb2-14"></a>    <span class="kw">this</span>-&gt;ymin = <span class="bu">std::</span>min(coord.v[<span class="dv">1</span>], <span class="kw">this</span>-&gt;ymin);</span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="kw">this</span>-&gt;xmax = <span class="bu">std::</span>max(coord.v[<span class="dv">0</span>], <span class="kw">this</span>-&gt;xmax);</span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="kw">this</span>-&gt;ymax = <span class="bu">std::</span>max(coord.v[<span class="dv">1</span>], <span class="kw">this</span>-&gt;ymax);</span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="cf">return</span> WK_CONTINUE; </span>
<span id="cb2-18"><a href="#cb2-18"></a>  }</span>
<span id="cb2-19"><a href="#cb2-19"></a>  </span>
<span id="cb2-20"><a href="#cb2-20"></a>  SEXP vectorEnd(<span class="at">const</span> <span class="dt">WKGeometryMeta_t</span>* meta) {</span>
<span id="cb2-21"><a href="#cb2-21"></a>    writable::doubles output = {<span class="kw">this</span>-&gt;xmin, <span class="kw">this</span>-&gt;ymin, <span class="kw">this</span>-&gt;xmax, <span class="kw">this</span>-&gt;ymax};</span>
<span id="cb2-22"><a href="#cb2-22"></a>    output.names() = {<span class="st">"xmin"</span>, <span class="st">"ymin"</span>, <span class="st">"xmax"</span>, <span class="st">"ymax"</span>};</span>
<span id="cb2-23"><a href="#cb2-23"></a>    <span class="cf">return</span> output;</span>
<span id="cb2-24"><a href="#cb2-24"></a>  }</span>
<span id="cb2-25"><a href="#cb2-25"></a>  </span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="kw">private</span>:</span>
<span id="cb2-27"><a href="#cb2-27"></a>  <span class="dt">double</span> xmin, ymin, xmax, ymax;</span>
<span id="cb2-28"><a href="#cb2-28"></a>};</span>
<span id="cb2-29"><a href="#cb2-29"></a></span>
<span id="cb2-30"><a href="#cb2-30"></a>[[<span class="at">cpp11</span>::<span class="at">linking_to</span>(<span class="at">wk</span>)]]</span>
<span id="cb2-31"><a href="#cb2-31"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]]</span>
<span id="cb2-32"><a href="#cb2-32"></a>sexp cpp_bbox_handler_new() {</span>
<span id="cb2-33"><a href="#cb2-33"></a>  <span class="cf">return</span> WKHandlerFactory&lt;BBoxHandler&gt;::create_xptr(<span class="kw">new</span> BBoxHandler());</span>
<span id="cb2-34"><a href="#cb2-34"></a>}</span></code></pre></div>
<p>In this handler, we only care about two types of events: the appearance of a coordinate and the end of the vector. In the wk API, the <code>vectorEnd()</code> method is where the return value is computed. We need a tiny bit more code to generate the handler in the form it can be used in R. This guarantees that other functions know that the object you’ve returned from C++ is a pointer to a wk handler.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">bbox_handler</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="../../reference/wk_void_handler.html">new_wk_handler</a></span><span class="op">(</span><span class="fu">cpp_bbox_handler_new</span><span class="op">(</span><span class="op">)</span>, <span class="st">"bbox_wk_handler"</span><span class="op">)</span>
<span class="op">}</span>

<span class="fu">bbox_handler</span><span class="op">(</span><span class="op">)</span>
<span class="co">#&gt; &lt;bbox_wk_handler at 0x48c7894900004140&gt;</span></code></pre></div>
<p>Once you have the object in R, you can use it with wk’s <code>handle_*()</code> functions such as <code><a href="../../reference/wk_void_handler.html">handle_wkt()</a></code> or <code><a href="../../reference/wk_void_handler.html">handle_wkb()</a></code>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span>
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="st">"POINT (0 1)"</span>, <span class="st">"GEOMETRYCOLLECTION (POINT (2 3))"</span><span class="op">)</span>,
  <span class="fu">bbox_handler</span><span class="op">(</span><span class="op">)</span>
<span class="op">)</span>
<span class="co">#&gt; xmin ymin xmax ymax </span>
<span class="co">#&gt;    0    1    2    3</span></code></pre></div>
</div>
<div id="lifecycle-of-a-c-handler" class="section level2">
<h2 class="hasAnchor">
<a href="#lifecycle-of-a-c-handler" class="anchor"></a>Lifecycle of a C++ handler</h2>
<p>The most important thing about a <code>wk_handler</code> is that, once created, it can only be used once:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">handler</span> <span class="op">&lt;-</span> <span class="fu">bbox_handler</span><span class="op">(</span><span class="op">)</span>
<span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/character.html">character</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">handler</span><span class="op">)</span>
<span class="co">#&gt; xmin ymin xmax ymax </span>
<span class="co">#&gt;  Inf  Inf -Inf -Inf</span>
<span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/character.html">character</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">handler</span><span class="op">)</span>
<span class="co">#&gt; Error in wk_cpp_handle_wkt(as_wkt(x), handler): Can't re-use a wk_handler</span></code></pre></div>
<p>If you need to program with user-supplied handlers, you can pass a function wherever a <code>wk_handler</code> was expected (the reader will call the function to obtain the fresh handler).</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">handler</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu">bbox_handler</span><span class="op">(</span><span class="op">)</span>
<span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/character.html">character</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">handler</span><span class="op">)</span>
<span class="co">#&gt; xmin ymin xmax ymax </span>
<span class="co">#&gt;  Inf  Inf -Inf -Inf</span>
<span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/character.html">character</a></span><span class="op">(</span><span class="op">)</span>, <span class="va">handler</span><span class="op">)</span>
<span class="co">#&gt; xmin ymin xmax ymax </span>
<span class="co">#&gt;  Inf  Inf -Inf -Inf</span></code></pre></div>
<p>When writing a handler, it is also important to consider cleaning up the resources you allocate. With a C++ handler some of this is taken care of for you because the deleter for the object is called at some point after the object is garbage collected. This is taken care of in the magical <code>WKHandlerFactory&lt;T&gt;::create_xptr(new T())</code>, which registers the deleter and catches any exceptions you may have thrown so that the your handling functions are safe to call from C. The default deleter will clean up any class members you’ve declared which is sufficient for most handlers you might want to write.</p>
<p>One situation in which you will specifically not want to rely on the deleter is a handler that writes to a file: because you have no control over <em>when</em> the deleter will run, you may reserve file access for longer than you intend. In these situations, you should open the file in <code>vectorStart()</code> and clean it up in <code>vectorFinally()</code>, which is guaranteed to run if <code>vectorStart()</code> is called.</p>
<p>A few more things to keep in mind when writing handlers:</p>
<ul>
<li>
<code>vectorStart()</code> may not run at all (e.g., if a handler object is created but never used).</li>
<li>You can and should throw exceptions to signify an error unless the method is marked <code>noexcept</code> (the deleter, <code>vectorFinally()</code>, and <code>error()</code>).</li>
</ul>
</div>
<div id="a-handler-in-c-1" class="section level2">
<h2 class="hasAnchor">
<a href="#a-handler-in-c-1" class="anchor"></a>A handler in C</h2>
<p>Depending on your background and the other libraries with which you are working, it may be easier or faster to write a handler in C. The below example is a direct translation of the C++ bounding box handler from above.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;Rinternals.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">"wk-v1.h"</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">"wk-v1-impl.c"</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="pp">#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="pp">#define MAX(a, b) (((a) &gt; (b)) ? (a) : (b)) </span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="dt">double</span> xmin, ymin, xmax, ymax;</span>
<span id="cb7-11"><a href="#cb7-11"></a>} BboxHandlerData_t;</span>
<span id="cb7-12"><a href="#cb7-12"></a></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="dt">char</span> bbox_handler_coord(<span class="dt">const</span> WKGeometryMeta_t* meta, <span class="dt">const</span> WKCoord_t coord, </span>
<span id="cb7-14"><a href="#cb7-14"></a>                        <span class="dt">uint32_t</span> nCoords, <span class="dt">uint32_t</span> coordId, <span class="dt">void</span>* userData) {</span>
<span id="cb7-15"><a href="#cb7-15"></a>  BboxHandlerData_t* data = (BboxHandlerData_t*) userData;</span>
<span id="cb7-16"><a href="#cb7-16"></a>  data-&gt;xmin = MIN(coord.v[<span class="dv">0</span>], data-&gt;xmin);</span>
<span id="cb7-17"><a href="#cb7-17"></a>  data-&gt;ymin = MIN(coord.v[<span class="dv">1</span>], data-&gt;ymin);</span>
<span id="cb7-18"><a href="#cb7-18"></a>  data-&gt;xmax = MAX(coord.v[<span class="dv">0</span>], data-&gt;xmax);</span>
<span id="cb7-19"><a href="#cb7-19"></a>  data-&gt;ymax = MAX(coord.v[<span class="dv">1</span>], data-&gt;ymax);</span>
<span id="cb7-20"><a href="#cb7-20"></a>  <span class="cf">return</span> WK_CONTINUE;</span>
<span id="cb7-21"><a href="#cb7-21"></a>}</span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a>SEXP bbox_handler_vector_end(<span class="dt">const</span> WKGeometryMeta_t* meta, <span class="dt">void</span>* userData) {</span>
<span id="cb7-24"><a href="#cb7-24"></a>  BboxHandlerData_t* data = (BboxHandlerData_t*) userData;</span>
<span id="cb7-25"><a href="#cb7-25"></a>  </span>
<span id="cb7-26"><a href="#cb7-26"></a>  <span class="dt">const</span> <span class="dt">char</span> *names[] = {<span class="st">"xmin"</span>, <span class="st">"ymin"</span>, <span class="st">"xmax"</span>, <span class="st">"ymax"</span>, <span class="st">""</span>};</span>
<span id="cb7-27"><a href="#cb7-27"></a>  SEXP output = PROTECT(Rf_mkNamed(REALSXP, names));</span>
<span id="cb7-28"><a href="#cb7-28"></a>  REAL(output)[<span class="dv">0</span>] = data-&gt;xmin;</span>
<span id="cb7-29"><a href="#cb7-29"></a>  REAL(output)[<span class="dv">1</span>] = data-&gt;ymin;</span>
<span id="cb7-30"><a href="#cb7-30"></a>  REAL(output)[<span class="dv">2</span>] = data-&gt;xmax;</span>
<span id="cb7-31"><a href="#cb7-31"></a>  REAL(output)[<span class="dv">3</span>] = data-&gt;ymax;</span>
<span id="cb7-32"><a href="#cb7-32"></a>  </span>
<span id="cb7-33"><a href="#cb7-33"></a>  UNPROTECT(<span class="dv">1</span>);</span>
<span id="cb7-34"><a href="#cb7-34"></a>  <span class="cf">return</span> output;</span>
<span id="cb7-35"><a href="#cb7-35"></a>}</span>
<span id="cb7-36"><a href="#cb7-36"></a></span>
<span id="cb7-37"><a href="#cb7-37"></a><span class="dt">void</span> bbox_handler_finalize(<span class="dt">void</span>* userData) {</span>
<span id="cb7-38"><a href="#cb7-38"></a>    BboxHandlerData_t* data = (BboxHandlerData_t*) userData;</span>
<span id="cb7-39"><a href="#cb7-39"></a>    free(data);</span>
<span id="cb7-40"><a href="#cb7-40"></a>}</span>
<span id="cb7-41"><a href="#cb7-41"></a></span>
<span id="cb7-42"><a href="#cb7-42"></a>SEXP c_bbox_handler_new() {</span>
<span id="cb7-43"><a href="#cb7-43"></a>  WKHandler_t* handler = wk_handler_create();</span>
<span id="cb7-44"><a href="#cb7-44"></a></span>
<span id="cb7-45"><a href="#cb7-45"></a>  handler-&gt;coord = &amp;bbox_handler_coord;</span>
<span id="cb7-46"><a href="#cb7-46"></a>  handler-&gt;vectorEnd = &amp;bbox_handler_vector_end;</span>
<span id="cb7-47"><a href="#cb7-47"></a>  </span>
<span id="cb7-48"><a href="#cb7-48"></a>  BboxHandlerData_t* data = (BboxHandlerData_t*) malloc(<span class="kw">sizeof</span>(BboxHandlerData_t));</span>
<span id="cb7-49"><a href="#cb7-49"></a>  data-&gt;xmin = R_PosInf;</span>
<span id="cb7-50"><a href="#cb7-50"></a>  data-&gt;ymin = R_PosInf;</span>
<span id="cb7-51"><a href="#cb7-51"></a>  data-&gt;xmax = R_NegInf;</span>
<span id="cb7-52"><a href="#cb7-52"></a>  data-&gt;ymax = R_NegInf;</span>
<span id="cb7-53"><a href="#cb7-53"></a>  handler-&gt;userData = data;</span>
<span id="cb7-54"><a href="#cb7-54"></a>  </span>
<span id="cb7-55"><a href="#cb7-55"></a>  <span class="cf">return</span> wk_handler_create_xptr(handler, R_NilValue, R_NilValue);</span>
<span id="cb7-56"><a href="#cb7-56"></a>}</span></code></pre></div>
<p>We need the same infrastructure on the R end (<code><a href="../../reference/wk_void_handler.html">new_wk_handler()</a></code>) to make sure read functions understand that the value is a pointer to a freshly created handler:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">bbox_handler_c</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="../../reference/wk_void_handler.html">new_wk_handler</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/CallExternal.html">.Call</a></span><span class="op">(</span><span class="st">"c_bbox_handler_new"</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span>

<span class="fu"><a href="../../reference/wk_void_handler.html">handle_wkt</a></span><span class="op">(</span>
  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="st">"POINT (0 1)"</span>, <span class="st">"GEOMETRYCOLLECTION (POINT (2 3))"</span><span class="op">)</span>,
  <span class="fu">bbox_handler_c</span><span class="op">(</span><span class="op">)</span>
<span class="op">)</span>
<span class="co">#&gt; xmin ymin xmax ymax </span>
<span class="co">#&gt;    0    1    2    3</span></code></pre></div>
</div>
<div id="lifecycle-of-a-c-handler-1" class="section level2">
<h2 class="hasAnchor">
<a href="#lifecycle-of-a-c-handler-1" class="anchor"></a>Lifecycle of a C handler</h2>
<p>The notes above about the lifecycle of a handler written in C++ apply to a handler written in C except that for the C handler you will have to explicitly <code>free()</code> anything you <code>malloc()</code>ed. In the above example, the <code>finalize()</code> method was used to free the <code>BboxHandlerData_t</code>. Another common pattern is to allocate an R object in <code>vectorStart()</code> (because this is where you have information about how may items are in the vector that is about to be read). This pattern of creating objects isn’t well-supported by the <code>PROTECT()</code>/<code>UNPROTECT()</code> pattern and is better-suited to <code>R_PreserveObject()</code> and <code>R_ReleaseObject()</code>. You can also use the fact that <code>VECSXP</code> vectors protect their elements to keep your R allocations from being garbage-collected while the handler is running.</p>
<p>Note that you can and should use the R API within your functions! This includes using <code>Rf_error()</code>, <code>Rf_allocVector()</code> and all the other functions that might <code>longjmp</code>: any reader calling handler functions from C++ use <code>cpp11::safe</code> to convert these to exceptions.</p>
</div>
<div id="a-reader-in-c" class="section level2">
<h2 class="hasAnchor">
<a href="#a-reader-in-c" class="anchor"></a>A reader in C++</h2>
</div>
<div id="a-reader-in-c-1" class="section level2">
<h2 class="hasAnchor">
<a href="#a-reader-in-c-1" class="anchor"></a>A reader in C</h2>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Dewey Dunnington, Edzer Pebesma.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>

---
title: "Understanding the wk C and C++ API"
---

```{r, include = FALSE}
library(cpp11)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

At the heart of the wk philosophy is the concept of a **handler**, whose job it is to respond to bits of geometric information as they are iterated over by the **reader**. These bits of information have a very specific structure and order such that the messages can be guaranteed to be backward-compatible for all time (for each version of the API). This means that the **reader** can focus on iterating over the data structure and **handlers** can focus on computing a value (usually) based on the geometries. The advantage of this system is that readers and handlers can be mixed and matched so that handlers can be used with many data structures! As an example, the wk package itself uses readers and handlers to power validation of and conversion between `wkt()`, `wkb()`, and `wksxp()` classes.

The wk API works with a **vector** of **features**: readers iterate over such vectors and handlers compute a value based on some or all of the features in the vector. Each **feature** can be `NULL` or contain exactly one **geometry** (although this geometry can be a collection or multi-geometry which can contain a tree of other geometries). A good way to visualize the structure, order, and type of messages passed to a **handler** is to use the `wk_debug_handler()` on some well-known text (WKT):

```{r}
library(wk)
handle_wkt(
  c(NA, "POINT (0 1)", "GEOMETRYCOLLECTION (POINT (2 3))"),
  wk_debug_handler()
)
```

The concept of a **vector** was inspired by the `sf::sfc()` data type and draws heavily from the [vctrs](https://vctrs.r-lib.org) framework. The concept of a **feature** draws from the implementations of the simple features specification in most databases and the support in R for "missing" values, which are not quite the same as an EMPTY geometry (in the same way that `NaN` and `NA` can be distinguished in R). The concept of a **geometry** is very much tied to (and was inspired by) the definition of a geometry in the (E)WKB, (E)WKT, and TWKB format specifications such that most of the information provided by these formats is passed along to handlers if it is available.

## A handler in C++

As an example, I'll write a handler that computes the 2D bounding box of its input (assuming Euclidean space). One way to go about this is to use the C++ extension of the C API. The approach is probably familiar: keep a running tally of the greatest and least values so far, updating every time information about a new coordinate is available.

```{cpp11}
#include <cmath>
#include "cpp11.hpp"
using namespace cpp11;
namespace writable = cpp11::writable;
#include "wk-v1.hpp"
#include "wk-v1-impl.c"

class BBoxHandler: public WKVoidHandler {
public:
  BBoxHandler(): xmin(R_PosInf), ymin(R_PosInf), xmax(R_NegInf), ymax(R_NegInf) {}
  
  char coord(const wk_meta_t* meta, wk_coord_t coord, uint32_t nCoords, uint32_t coord_id) {
    this->xmin = std::min(coord.v[0], this->xmin);
    this->ymin = std::min(coord.v[1], this->ymin);
    this->xmax = std::max(coord.v[0], this->xmax);
    this->ymax = std::max(coord.v[1], this->ymax);
    return WK_CONTINUE; 
  }
  
  SEXP vectorEnd(const wk_meta_t* meta) {
    writable::doubles output = {this->xmin, this->ymin, this->xmax, this->ymax};
    output.names() = {"xmin", "ymin", "xmax", "ymax"};
    return output;
  }
  
private:
  double xmin, ymin, xmax, ymax;
};

[[cpp11::linking_to(wk)]]
[[cpp11::register]]
sexp cpp_bbox_handler_new() {
  return WKHandlerFactory<BBoxHandler>::create_xptr(new BBoxHandler());
}
```

In this handler, we only care about two types of events: the appearance of a coordinate and the end of the vector. In the wk API, the `vectorEnd()` method is where the return value is computed. We need a tiny bit more code to generate the handler in the form it can be used in R. This guarantees that other functions know that the object you've returned from C++ is a pointer to a wk handler.

```{r}
bbox_handler <- function() {
  new_wk_handler(cpp_bbox_handler_new(), "bbox_wk_handler")
}

bbox_handler()
```

Once you have the object in R, you can use it with wk's `handle_*()` functions such as `handle_wkt()` or `handle_wkb()`:

```{r}
handle_wkt(
  c(NA, "POINT (0 1)", "GEOMETRYCOLLECTION (POINT (2 3))"),
  bbox_handler()
)
```

## Lifecycle of a C++ handler

The most important thing about a `wk_handler` is that, once created, it can only be used once:

```{r, error = TRUE}
handler <- bbox_handler()
handle_wkt(character(), handler)
handle_wkt(character(), handler)
```

If you need to program with user-supplied handlers, you can pass a function wherever a `wk_handler` was expected (the reader will call the function to obtain the fresh handler).

```{r}
handler <- function() bbox_handler()
handle_wkt(character(), handler)
handle_wkt(character(), handler)
```

When writing a handler, it is also important to consider cleaning up the resources you allocate. With a C++ handler some of this is taken care of for you because the deleter for the object is called at some point after the object is garbage collected. This is taken care of in the magical `WKHandlerFactory<T>::create_xptr(new T())`, which registers the deleter and catches any exceptions you may have thrown so that the your handling functions are safe to call from C. The default deleter will clean up any class members you've declared which is sufficient for most handlers you might want to write. 

One situation in which you will specifically not want to rely on the deleter is a handler that writes to a file: because you have no control over *when* the deleter will run, you may reserve file access for longer than you intend. In these situations, you should open the file in `vectorStart()` and clean it up in `vectorFinally()`, which is guaranteed to run if `vectorStart()` is called.

A few more things to keep in mind when writing handlers:

- `vectorStart()` may not run at all (e.g., if a handler object is created but never used).
- You can and should throw exceptions to signify an error unless the method is marked `noexcept` (the deleter, `vectorFinally()`, and `error()`).

## A handler in C

Depending on your background and the other libraries with which you are working, it may be easier or faster to write a handler in C. The below example is a direct translation of the C++ bounding box handler from above.

```{r, include=FALSE}
Sys.setenv(
  PKG_CFLAGS = paste0("-I", system.file("include", package = "wk"))
)
```

```{c, results = "hide"}
#include <Rinternals.h>
#include <stdlib.h>
#include "wk-v1.h"
#include "wk-v1-impl.c"

#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MAX(a, b) (((a) > (b)) ? (a) : (b)) 

typedef struct {
  double xmin, ymin, xmax, ymax;
} BboxHandlerData_t;

char bbox_handler_coord(const wk_meta_t* meta, const wk_coord_t coord, 
                        uint32_t nCoords, uint32_t coord_id, void* handler_data) {
  BboxHandlerData_t* data = (BboxHandlerData_t*) handler_data;
  data->xmin = MIN(coord.v[0], data->xmin);
  data->ymin = MIN(coord.v[1], data->ymin);
  data->xmax = MAX(coord.v[0], data->xmax);
  data->ymax = MAX(coord.v[1], data->ymax);
  return WK_CONTINUE;
}

SEXP bbox_handler_vector_end(const wk_meta_t* meta, void* handler_data) {
  BboxHandlerData_t* data = (BboxHandlerData_t*) handler_data;
  
  const char *names[] = {"xmin", "ymin", "xmax", "ymax", ""};
  SEXP output = PROTECT(Rf_mkNamed(REALSXP, names));
  REAL(output)[0] = data->xmin;
  REAL(output)[1] = data->ymin;
  REAL(output)[2] = data->xmax;
  REAL(output)[3] = data->ymax;
  
  UNPROTECT(1);
  return output;
}

void bbox_handler_finalize(void* handler_data) {
    BboxHandlerData_t* data = (BboxHandlerData_t*) handler_data;
    free(data);
}

SEXP c_bbox_handler_new() {
  WKHandler_t* handler = wk_handler_create();

  handler->coord = &bbox_handler_coord;
  handler->vectorEnd = &bbox_handler_vector_end;
  
  BboxHandlerData_t* data = (BboxHandlerData_t*) malloc(sizeof(BboxHandlerData_t));
  data->xmin = R_PosInf;
  data->ymin = R_PosInf;
  data->xmax = R_NegInf;
  data->ymax = R_NegInf;
  handler->handler_data = data;
  
  return wk_handler_create_xptr(handler, R_NilValue, R_NilValue);
}
```

We need the same infrastructure on the R end (`new_wk_handler()`) to make sure read functions understand that the value is a pointer to a freshly created handler:

```{r}
bbox_handler_c <- function() {
  new_wk_handler(.Call("c_bbox_handler_new"))
}

handle_wkt(
  c(NA, "POINT (0 1)", "GEOMETRYCOLLECTION (POINT (2 3))"),
  bbox_handler_c()
)
```

## Lifecycle of a C handler

The notes above about the lifecycle of a handler written in C++ apply to a handler written in C except that for the C handler you will have to explicitly `free()` anything you `malloc()`ed. In the above example, the `finalize()` method was used to free the `BboxHandlerData_t`. Another common pattern is to allocate an R object in `vectorStart()` (because this is where you have information about how may items are in the vector that is about to be read). This pattern of creating objects isn't well-supported by the `PROTECT()`/`UNPROTECT()` pattern and is better-suited to `R_PreserveObject()` and `R_ReleaseObject()`. You can also use the fact that `VECSXP` vectors protect their elements to keep your R allocations from being garbage-collected while the handler is running.

Note that you can and should use the R API within your functions! This includes using `Rf_error()`, `Rf_allocVector()` and all the other functions that might `longjmp`: any reader calling handler functions from C++ use `cpp11::safe` to convert these to exceptions.

## A reader in C++


## A reader in C

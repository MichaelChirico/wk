---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# wk

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![R build status](https://github.com/paleolimbot/wk/workflows/R-CMD-check/badge.svg)](https://github.com/paleolimbot/wk/actions)
[![Codecov test coverage](https://codecov.io/gh/paleolimbot/wk/branch/master/graph/badge.svg)](https://codecov.io/gh/paleolimbot/wk?branch=master)
<!-- badges: end -->

The goal of wk is to provide lightweight R and C++ infrastructure for packages to use well-known formats (well-known binary and well-known text) as input and/or output without requiring external software. Well-known binary is very fast to read and write, whereas well-known text is human-readable and human-writable. Together, these formats allow for efficient interchange between software packages (WKB), and highly readable tests and examples (WKT).

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("remotes")
remotes::install_github("paleolimbot/wk")
```

If you can load the package, you're good to go!

```{r}
library(wk)
```

## Basic vector classes for WKT and WKB

Want to return an object that any spatial package can read? Use `wkt()` to mark a character vector as containing well-known text, or `wkb()` to mark a vector as well-known binary. These have some basic vector features built in, which means you can subset, repeat, concatenate, and put these objects in a data frame or tibble. These come with built-in `format()` and `print()` methods.

```{r}
wkt("POINT (30 10)")
as_wkb(wkt("POINT (30 10)"))
```

## Extract coordinates and meta information

One of the main drawbacks to passing around geomtries in WKB is that the format is opaque to R users, who need coordinates as R object rather than binary vectors. In addition to `print()` and `plot()` methods for `wkb()` vectors, the `wk*_meta()` and `wk*_coords()` functions provide usable coordinates and feature meta.

```{r}
wkt_coords("POINT ZM (1 2 3 4)")
wkt_meta("POINT ZM (1 2 3 4)")
```

## Well-known R objects?

The wk package experimentally generates (and parses) well-known "s" expressions (the C name for R objects). This is similar to the format that [sf](https://r-spatial.github.io/sf) uses.

```{r}
wkt_translate_wksxp("POINT (30 10)")
```

## Dependencies

The wk package imports [Rcpp](https://cran.r-project.org/package=Rcpp).

## Using the C++ headers

The wk package takes an event-based approach to parsing inspired by the event-based SAX XML parser. This makes the readers and writers highly re-usable! This system is class-based, so you will have to make your own subclass of `WKGeometryHandler` and wire it up to a `WKReader` to do anything useful.

```{Rcpp}
// If you're writing code in a package, you'll also
// have to put 'wk' in your `LinkingTo:` description field
// [[Rcpp::depends(wk)]]

#include <Rcpp.h>
#include "wk/rcpp-io.h"
#include "wk/wkt-reader.h"
using namespace Rcpp;

class CustomHandler: public WKGeometryHandler {
public:
  
  void nextFeatureStart(size_t featureId) {
    Rcout << "Do something before feature " << featureId << "\n";
  }
  
  void nextFeatureEnd(size_t featureId) {
    Rcout << "Do something after feature " << featureId << "\n";
  }
};

// [[Rcpp::export]]
void wkt_read_custom(CharacterVector wkt) {
  WKCharacterVectorProvider provider(wkt);
  WKTReader reader(provider);
  
  CustomHandler handler;
  reader.setHandler(&handler);
  
  while (reader.hasNextFeature()) {
    reader.iterateFeature();
  }
}
```

On our example point, this prints the following:

```{r}
wkt_read_custom("POINT (30 10)")
```

The full handler interface includes methods for the start and end of features, geometries (which may be nested), linear rings, coordinates, and parse errors. You can preview what will get called for a given geometry using `wkb|wkt_debug()` functions.

```{r}
wkt_debug("POINT (30 10)")
```

## Performance

This package is mostly designed for no system dependencies and flexibility, but also happens to be really fast for some common operations.

```{r, echo=FALSE}
# set up the test data
nc_wkb <- geovctrs::geo_nc$geometry
nc_wkt <- geovctrs::as_geo_wkt(nc_wkb)
nc_WKB <- nc_wkb
class(nc_WKB) <- "WKB"
nc_sfc <- sf::st_as_sfc(nc_WKB, EWKB = TRUE)
nc_sp <- sf::as_Spatial(nc_sfc)
wkt_ptype <- geovctrs::geo_wkt()
wkb_ptype <- geovctrs::geo_wkb()
```

Read WKB + Write WKB:

```{r}
bench::mark(
  wk = wk:::wkb_translate_wkb(nc_wkb),
  geos_c = geovctrs:::geovctrs_cpp_convert(nc_wkb, wkb_ptype),
  sf = sf:::CPL_read_wkb(sf:::CPL_write_wkb(nc_sfc, EWKB = TRUE), EWKB = TRUE),
  wkb = wkb::readWKB(wkb::writeWKB(nc_sp)),
  check = FALSE
)
```

Read WKB + Write WKT:

```{r}
bench::mark(
  wk = wk:::wkb_translate_wkt(nc_wkb),
  geos_c = geovctrs:::geovctrs_cpp_convert(nc_wkb, wkt_ptype),
  sf = sf:::st_as_text.sfc(sf:::st_as_sfc.WKB(nc_WKB, EWKB = TRUE)),
  wellknown = lapply(nc_wkb, wellknown::wkb_wkt),
  check = FALSE
)
```

Read WKT + Write WKB:

```{r}
bench::mark(
  wk = wk:::wkt_translate_wkb(nc_wkt),
  geos_c = geovctrs:::geovctrs_cpp_convert(nc_wkt, wkb_ptype),
  sf = sf:::CPL_write_wkb(sf:::st_as_sfc.character(nc_wkt), EWKB = TRUE),
  wellknown = lapply(nc_wkt, wellknown::wkt_wkb),
  check = FALSE
)
```

Read WKT + Write WKT:

```{r}
bench::mark(
  wk = wk:::wkt_translate_wkt(nc_wkt),
  geos_c = geovctrs:::geovctrs_cpp_convert(nc_wkt, wkt_ptype),
  sf = sf:::st_as_text.sfc(sf:::st_as_sfc.character(nc_wkt)),
  check = FALSE
)
```

Generate coordinates:

```{r}
bench::mark(
  wk_wkb = wk::wkb_coords(rep(nc_wkb, 10)),
  sfheaders = sfheaders::sfc_to_df(rep(nc_sfc, 10)),
  sf = sf::st_coordinates(rep(nc_sfc, 10)),
  check = FALSE
)
```
